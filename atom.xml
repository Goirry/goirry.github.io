<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Goirry's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://goirry.github.io/"/>
  <updated>2015-10-31T09:18:26.000Z</updated>
  <id>http://goirry.github.io/</id>
  
  <author>
    <name><![CDATA[Goirry]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[应用及视图的生命周期]]></title>
    <link href="http://goirry.github.io/2015/09/15/AppViewCircleLife/"/>
    <id>http://goirry.github.io/2015/09/15/AppViewCircleLife/</id>
    <published>2015-09-15T10:12:36.000Z</published>
    <updated>2015-10-31T09:18:26.000Z</updated>
    <content type="html"><![CDATA[<p>应用和视图的生命周期，应该算是iOS开发最基本的平台机制了吧。</p>
<h2 id="应用生命周期的代理方法">应用生命周期的代理方法</h2><p>UIApplicationDelegate协议的代理方法:</p>
<p>应用启动但还没进入状态保存时调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>application:<span class="params">(<span class="variable">UIApplication</span> *)</span>application willFinishLaunchingWithOptions:<span class="params">(<span class="variable">NSDictionary</span> *)</span>launchOptions</span></span><br></pre></td></tr></table></figure></p>
<p>应用启动基本完成程序准备开始运行时调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>application:<span class="params">(<span class="variable">UIApplication</span> *)</span>application didFinishLaunchingWithOptions:<span class="params">(<span class="variable">NSDictionary</span> *)</span>launchOptions</span></span><br></pre></td></tr></table></figure></p>
<p>当应用程序进入活动状态调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>applicationDidBecomeActive:<span class="params">(<span class="variable">UIApplication</span> *)</span>application</span></span><br></pre></td></tr></table></figure></p>
<p>当应用程序将要进入非活动状态调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>applicationWillResignActive:<span class="params">(<span class="variable">UIApplication</span> *)</span>application</span></span><br></pre></td></tr></table></figure></p>
<p>当程序退到后台的时候调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>applicationDidEnterBackground:<span class="params">(<span class="variable">UIApplication</span> *)</span>application</span></span><br></pre></td></tr></table></figure></p>
<p>当程序进入前台的时候调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>applicationWillEnterForeground:<span class="params">(<span class="variable">UIApplication</span> *)</span>application</span></span><br></pre></td></tr></table></figure></p>
<p>当程序将要退出时被调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>applicationWillTerminate:<span class="params">(<span class="variable">UIApplication</span> *)</span>application</span></span><br></pre></td></tr></table></figure></p>
<h2 id="UIViewController的生命周期">UIViewController的生命周期</h2><ol>
<li><p>loadView<br>此方法用在<code>初始化关键view</code>, 当访问ViewController的view属性时，view如果此时是nil，那么ViewController会自动调用loadView方法来初始化一个UIView并赋值给<code>self.view</code>属性。如果没有先调用了<code>[supper loadView];</code>，也没有对view初始化，不能调用view的<code>getter</code>方法，否则将导致死循环。<br>如果没有重载loadView方法，则UIViewController会从<code>Nib</code>或<code>StoryBoard</code>中查找默认的loadView，默认的loadView会返回一个<code>空白的UIView对象</code>。</p>
</li>
<li><p>viewDidLoad<br>当ViewController的view对象载入内存后调用，用于对view进行额外的初始化操作。</p>
</li>
<li><p>viewWillAppear<br>在view即将添加到视图层级中(显示给用户看)且任意显示动画切换之前调用(这个时候supperView还是nil)。这个方法中完成任何与视图显示相关的任务，例如改变视图方向、状态栏方向、视图显示样式等</p>
</li>
<li><p>viewDidAppear<br>在view被添加到视图层级中，显示动画切换之后调用(这时view已经添加到supperView中)。在这个方法中执行视图显示相关附件任务，如果重载了这个方法，必须在方法中调用<code>[supper viewDidAppear];</code>。</p>
</li>
<li><p>viewWillLayoutSubviews<br>view即将布局其子视图，会在view调用<code>layoutSubviews</code>之前调用。比如view的<code>bounds</code>属性改变了(例如状态栏从不显示到显示，视图方向变化)，要调整Subviews的位置，在调整之前要做的一些工作就可以在该方法中实现。</p>
</li>
<li><p>viewDidLayoutSubviews<br>view已经布局其子视图，会在view调用完<code>layoutSubviews</code>后调用。</p>
</li>
<li><p>viewWillDisappear<br>view即将从superView中移除且移除动画切换之前，此时还没有调用<code>removeFromSuperview</code>。</p>
</li>
<li><p>viewDidDisappear<br>view从superView中移除，移除动画切换之后调用，此时已调用<code>removeFromSuperview</code>。</p>
</li>
<li><p>viewWillUnload<br>在view对象从内存中释放之前调用。在<code>iOS6.0</code>开始就废弃了，该方法不再会调用。</p>
</li>
<li><p>viewDidUnload<br>在view对象从内存中释放之后调用，此时view为<code>nil</code>。在<code>iOS6.0</code>开始就废弃了，该方法不再会调用。</p>
</li>
</ol>
<a id="more"></a>
<h2 id="生命周期方法的调用顺序">生命周期方法的调用顺序</h2><p>清楚生命周期就清楚了应用的整体流程，对代码的执行顺序有所了解，知道系统会在什么情况下调用什么方法，也就可以对程序更加进一步的理解和掌控。闲话不多说，下面我们来看一下应用从启动到终止都调用了哪些方法:</p>
<ul>
<li><p>启动应用</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">application:</span> <span class="string">didFinishLaunchingWithOptions:</span></span><br><span class="line">RootViewController loadView</span><br><span class="line">RootViewController <span class="string">viewDidLoad:</span></span><br><span class="line">RootViewController <span class="string">viewWillAppear:</span></span><br><span class="line">RootViewController viewWillLayoutSubviews</span><br><span class="line">RottViewController viewDidLayoutSubviews</span><br><span class="line">RootViewController <span class="string">viewDidAppear:</span></span><br><span class="line"><span class="string">applicationDidBecomeActive:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从RootViewController通过<code>Push方式</code>跳转到SecondViewController</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SecondViewController <span class="string">viewDidLoad:</span></span><br><span class="line">RootViewController <span class="string">viewWillDisappear:</span></span><br><span class="line">SecondViewController <span class="string">viewWillAppear:</span></span><br><span class="line">RootViewController <span class="string">viewDidDisappear:</span></span><br><span class="line">SecondViewController <span class="string">viewDidAppear:</span></span><br><span class="line"><span class="comment">// 通过Present方式跳转的话，4、5调换顺序。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从SecondViewController通过<code>Pop方式</code>跳转到RootViewController</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SecondViewController <span class="string">viewWillDisappear:</span></span><br><span class="line">RootViewController <span class="string">viewWillAppear:</span></span><br><span class="line">SecondViewController <span class="string">viewDidDisappear:</span></span><br><span class="line">RootViewController <span class="string">viewDidAppear:</span></span><br><span class="line">SecondViewController dealloc</span><br><span class="line"><span class="comment">// 通过Present方式跳转的话，3、4调换顺序</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>按下Home键使App进入后台(<code>ViewController不会做响应</code>)</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">applicationWillResignActive:</span></span><br><span class="line"><span class="label">applicationDidEnterBackground:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>点击App从后台进入到前台(<code>ViewController不会做响应</code>)</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">applicationWillEnterForeground:</span></span><br><span class="line"><span class="label">applicationDidBecomeActive:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下拉系统的通知栏或上拉出系统的底部控制中心(<code>ViewController不会做响应</code>)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">applicationWillResignActive:</span> <span class="comment">// Show</span></span><br><span class="line"><span class="string">applicationDidBecomeActive:</span> <span class="comment">// Hide</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上就是程序在各种状态下自动调用方法的顺序，这是本人写的Demo打印的顺序，两个文件同时执行方法的顺序可能会出现误差，但是单个文件当中的方法执行顺序是一定的。</p>
<p>不过看到两个<code>ViewController</code>跳转时，执行顺序居然会是交叉调用的，也是很有意思。</p>
<h2 id="生命周期的流程图片">生命周期的流程图片</h2><p>当应用从开始加载到进入后台:<br><img src="http://7xnejb.com1.z0.glb.clouddn.com/images/app_enter_background.png" alt="" title="应用从开始加载到进入后台的生命周期流程图"></p>
<p>当用户切换应用时:<br><img src="http://7xnejb.com1.z0.glb.clouddn.com/images/app_enter_foreground.png" alt="" title="用户切换应用时的生命周期流程图"></p>
<p>ViewController的生命周期:<br><img src="http://7xnejb.com1.z0.glb.clouddn.com/images/UIViewController_Life_Circle.jpg" alt="" title="ViewController的生命周期图"></p>
<p>以上是生命周期的图片，非常清晰且详细的描述了应用以及ViewController的生命周期</p>
<p>把流程图看懂<code>iOS应用开发的生命周期</code>自然了然于胸。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>应用和视图的生命周期，应该算是iOS开发最基本的平台机制了吧。</p>
<h2 id="应用生命周期的代理方法">应用生命周期的代理方法</h2><p>UIApplicationDelegate协议的代理方法:</p>
<p>应用启动但还没进入状态保存时调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>application:<span class="params">(<span class="variable">UIApplication</span> *)</span>application willFinishLaunchingWithOptions:<span class="params">(<span class="variable">NSDictionary</span> *)</span>launchOptions</span></span><br></pre></td></tr></table></figure></p>
<p>应用启动基本完成程序准备开始运行时调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>application:<span class="params">(<span class="variable">UIApplication</span> *)</span>application didFinishLaunchingWithOptions:<span class="params">(<span class="variable">NSDictionary</span> *)</span>launchOptions</span></span><br></pre></td></tr></table></figure></p>
<p>当应用程序进入活动状态调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>applicationDidBecomeActive:<span class="params">(<span class="variable">UIApplication</span> *)</span>application</span></span><br></pre></td></tr></table></figure></p>
<p>当应用程序将要进入非活动状态调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>applicationWillResignActive:<span class="params">(<span class="variable">UIApplication</span> *)</span>application</span></span><br></pre></td></tr></table></figure></p>
<p>当程序退到后台的时候调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>applicationDidEnterBackground:<span class="params">(<span class="variable">UIApplication</span> *)</span>application</span></span><br></pre></td></tr></table></figure></p>
<p>当程序进入前台的时候调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>applicationWillEnterForeground:<span class="params">(<span class="variable">UIApplication</span> *)</span>application</span></span><br></pre></td></tr></table></figure></p>
<p>当程序将要退出时被调用<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>applicationWillTerminate:<span class="params">(<span class="variable">UIApplication</span> *)</span>application</span></span><br></pre></td></tr></table></figure></p>
<h2 id="UIViewController的生命周期">UIViewController的生命周期</h2><ol>
<li><p>loadView<br>此方法用在<code>初始化关键view</code>, 当访问ViewController的view属性时，view如果此时是nil，那么ViewController会自动调用loadView方法来初始化一个UIView并赋值给<code>self.view</code>属性。如果没有先调用了<code>[supper loadView];</code>，也没有对view初始化，不能调用view的<code>getter</code>方法，否则将导致死循环。<br>如果没有重载loadView方法，则UIViewController会从<code>Nib</code>或<code>StoryBoard</code>中查找默认的loadView，默认的loadView会返回一个<code>空白的UIView对象</code>。</p>
</li>
<li><p>viewDidLoad<br>当ViewController的view对象载入内存后调用，用于对view进行额外的初始化操作。</p>
</li>
<li><p>viewWillAppear<br>在view即将添加到视图层级中(显示给用户看)且任意显示动画切换之前调用(这个时候supperView还是nil)。这个方法中完成任何与视图显示相关的任务，例如改变视图方向、状态栏方向、视图显示样式等</p>
</li>
<li><p>viewDidAppear<br>在view被添加到视图层级中，显示动画切换之后调用(这时view已经添加到supperView中)。在这个方法中执行视图显示相关附件任务，如果重载了这个方法，必须在方法中调用<code>[supper viewDidAppear];</code>。</p>
</li>
<li><p>viewWillLayoutSubviews<br>view即将布局其子视图，会在view调用<code>layoutSubviews</code>之前调用。比如view的<code>bounds</code>属性改变了(例如状态栏从不显示到显示，视图方向变化)，要调整Subviews的位置，在调整之前要做的一些工作就可以在该方法中实现。</p>
</li>
<li><p>viewDidLayoutSubviews<br>view已经布局其子视图，会在view调用完<code>layoutSubviews</code>后调用。</p>
</li>
<li><p>viewWillDisappear<br>view即将从superView中移除且移除动画切换之前，此时还没有调用<code>removeFromSuperview</code>。</p>
</li>
<li><p>viewDidDisappear<br>view从superView中移除，移除动画切换之后调用，此时已调用<code>removeFromSuperview</code>。</p>
</li>
<li><p>viewWillUnload<br>在view对象从内存中释放之前调用。在<code>iOS6.0</code>开始就废弃了，该方法不再会调用。</p>
</li>
<li><p>viewDidUnload<br>在view对象从内存中释放之后调用，此时view为<code>nil</code>。在<code>iOS6.0</code>开始就废弃了，该方法不再会调用。</p>
</li>
</ol>]]>
    
    </summary>
    
      <category term="OC" scheme="http://goirry.github.io/tags/OC/"/>
    
      <category term="iOS" scheme="http://goirry.github.io/tags/iOS/"/>
    
      <category term="生命周期" scheme="http://goirry.github.io/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
      <category term="iOS" scheme="http://goirry.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Foundation基础]]></title>
    <link href="http://goirry.github.io/2015/08/11/foundation-base/"/>
    <id>http://goirry.github.io/2015/08/11/foundation-base/</id>
    <published>2015-08-11T10:28:12.000Z</published>
    <updated>2015-11-02T07:22:53.000Z</updated>
    <content type="html"><![CDATA[<p>首先，<code>Foundation框架</code>是iOS开发当中的基本框架，所以以下的知识点都是iOS开发中最最基础的。</p>
<h2 id="结构体">结构体</h2><ul>
<li><code>NSRange(location, length)</code></li>
<li><code>NSPoint/CGPoint(x, y)</code></li>
<li><code>NSSize/CGSize(width, height)</code></li>
<li><code>NSRect/CGRect(CGPoint, CGSize)</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"Hello iOS,This is a string."</span>;</span><br><span class="line"><span class="built_in">NSRange</span> range = [str rangeOfString:<span class="string">@"OS"</span>];</span><br><span class="line"><span class="keyword">if</span> (range<span class="variable">.location</span> == <span class="built_in">NSNotFound</span>) &#123; <span class="comment">// NSNotFound等于-1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"字符串找不到"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"匹配字符串在查找字符串的位置:%ld, 长度:%ld"</span>, range<span class="variable">.location</span>, range<span class="variable">.length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化写法</span></span><br><span class="line"><span class="built_in">CGPoint</span> point = <span class="built_in">NSMakePoint</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">CGPoint</span> point1 = <span class="built_in">CGPointMake</span>(<span class="number">20</span>, <span class="number">25</span>);</span><br><span class="line"><span class="built_in">NSSize</span> size = <span class="built_in">CGSizeMake</span>(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">80</span>);</span><br><span class="line"><span class="built_in">CGRect</span> rect1 = &#123;<span class="built_in">CGPointZero</span>, <span class="built_in">CGSizeMake</span>(<span class="number">200</span>, <span class="number">200</span>)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *strPoint = <span class="built_in">NSStringFromCGPoint</span>(point); <span class="comment">// 输出:&#123;10, 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CGPointZero</span> == <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 常用原点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较</span></span><br><span class="line"><span class="built_in">CGPointEqualToPoint</span>(point, point1);</span><br><span class="line"><span class="built_in">CGRectEqualToRect</span>(rect, rect1); <span class="comment">// 其他写法均类似 就不一一列举</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串">字符串</h2><ul>
<li><code>NSString</code> 不可变字符串</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化写法</span></span><br><span class="line"><span class="built_in">NSString</span> *string1 = <span class="string">@"123"</span>; <span class="comment">// 常用</span></span><br><span class="line"><span class="built_in">NSString</span> *string2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"string123"</span>]; <span class="comment">// 繁琐, 一般不用</span></span><br><span class="line"><span class="built_in">NSString</span> *string3 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"Age = %d"</span>, <span class="number">99</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言字符串-&gt;OC字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *ocString1 = [[<span class="built_in">NSString</span> alloc] initWithUTF8String:<span class="string">"C language string"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *ocString2 = [[<span class="built_in">NSString</span> alloc] stringWithUTF8String:<span class="string">"C language string"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// OC字符串-&gt;C语言字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cString = [<span class="string">@"OC string"</span> UTF8String];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line"><span class="built_in">NSString</span> *fileString = [[<span class="built_in">NSString</span> alloc] initWithContentsOfFile:<span class="string">@"/Users/Guo/Document/1.txt"</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li><code>NSMutableString</code> 可变字符串</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSMutableString是NSString的子类 方法继承</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *mutableStr = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"age is 10"</span>];</span><br><span class="line"><span class="comment">// 追加字符串</span></span><br><span class="line">[mutableStr appendString:<span class="string">@" 11 12"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSRange</span> range = [mutableStr rangeOfString:<span class="string">@" is"</span>];</span><br><span class="line"><span class="comment">// 删除范围内的字符串</span></span><br><span class="line">[mutableStr deleteCharactersInRange:range];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *unchangeableString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"age is 10"</span>];</span><br><span class="line"><span class="comment">// 重新创建出一个新的字符串 并且基于原字符串追加</span></span><br><span class="line"><span class="built_in">NSString</span> *unchangeableString1 = [unchangeableString stringByAppendingString:<span class="string">@" 11 12"</span>];</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="URL资源路径">URL资源路径</h2><p>URL格式: <code>资源头://路径</code></p>
<ul>
<li>本地资源路径: <code>file://</code></li>
<li>网络资源路径: <code>http://</code>、<code>ftp://</code>等</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义URL 也相当于NSString-&gt;NSURL</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [[<span class="built_in">NSURL</span> alloc] initWithString:<span class="string">@"file:///Users/Guo/Document/1.txt"</span>];</span><br><span class="line"><span class="comment">// 定义文件地址URL 直接传入文件地址</span></span><br><span class="line"><span class="built_in">NSURL</span> *fileUrl = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"/Users/Kevin_Guo/Document/1.txt"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSURL-&gt;NSString</span></span><br><span class="line"><span class="built_in">NSString</span> *urlPath = url<span class="variable">.path</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过URL读取文件内容</span></span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithContentsOfURL:url encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 通过文件路径读取文件内容</span></span><br><span class="line"><span class="built_in">NSString</span> *fileContentStr = [<span class="built_in">NSString</span> stringWithContentsOfFile:<span class="string">@"Users/Guo/Document/1.txt"</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<h2 id="集合类">集合类</h2><ul>
<li>数组<ul>
<li>有序<ul>
<li><code>NSArray</code> 不可变</li>
<li><code>NSMutableArray</code> 可变</li>
</ul>
</li>
<li>无序<ul>
<li><code>NSSet</code> 不可变</li>
<li><code>NSMutableSet</code> 可变</li>
</ul>
</li>
</ul>
</li>
<li>字典<ul>
<li><code>NSDictionary</code> 不可变</li>
<li><code>NSMutableDictionary</code> 可变</li>
</ul>
</li>
</ul>
<blockquote>
<p>OC当中任何集合类都不能存放<code>非OC对象</code>，比如<code>基本数据类型</code>、<code>struct</code>、<code>enum</code>等。<br>也不能存放空值<code>nil</code>。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------NSArray------------</span></span><br><span class="line"><span class="keyword">int</span> ages[<span class="number">10</span>] = &#123;<span class="number">5</span>, <span class="number">55</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>&#125;; <span class="comment">// C数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OC数组不能存放非OC对象类型 比如基本类型, struct, enum等  OC数组不能存放nil值</span></span><br><span class="line"><span class="comment">// 初始化空数组 并且这个数组永远是空的 不可变</span></span><br><span class="line"><span class="built_in">NSArray</span> *arr = [<span class="built_in">NSArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *array1 = [<span class="built_in">NSArray</span> arrayWithObject:<span class="string">@"jack"</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *array2 = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"jack"</span>, <span class="string">@"rose"</span>, <span class="literal">nil</span>]; <span class="comment">// nil是数组元素结束的标记</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"数组个数:%ld"</span>,[array2 count]);<span class="comment">//数组个数</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"第二个数组元素:%@"</span>, [array2 objectAtIndex:<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, array2[<span class="number">1</span>]);<span class="comment">// 编译器特性 会自动转换成上面的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSArray的便捷初始化方法 编译器特性</span></span><br><span class="line"><span class="built_in">NSArray</span> *array3 = @[<span class="string">@"jack"</span>, <span class="string">@"rose"</span>, <span class="string">@"sam"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">id</span> obj <span class="keyword">in</span> array3) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"数组元素的序号:%ld"</span>, [array3 indexOfObject:obj]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"数组元素:%@"</span>, obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代循环 遍历数组</span></span><br><span class="line">[array2 enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"序号:%ld --&gt; 值:%@"</span>, idx, obj);</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">        *stop = <span class="literal">YES</span>; <span class="comment">// 停止可控</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组拼接成字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *stringFromArray = [array3 componentsJoinedByString:<span class="string">@"-"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, stringFromArray); <span class="comment">// 打印结果:jack-rose-sam</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把字符串拆分成数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *arrayFromString = [stringFromArray componentsSeparatedByString:<span class="string">@"-"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> arrayFromString) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------NSMutableArray-----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化空的可变数组</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *mutableArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="built_in">NSMutableArray</span> * mutableArr1 = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"jack"</span>, <span class="string">@"rose"</span>, <span class="string">@"jim"</span>, <span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">[mutableArr addObject:<span class="string">@"string"</span>]; <span class="comment">// 可变数组添加元素</span></span><br><span class="line">[mutableArr count]; <span class="comment">// 数组元素数量</span></span><br><span class="line">[mutableArr removeAllObjects]; <span class="comment">// 删除数组中所有元素</span></span><br><span class="line">[mutableArr removeObject:<span class="string">@"jack"</span>]; <span class="comment">// 删除数组中指定对象</span></span><br><span class="line">[mutableArr removeObjectAtIndex:<span class="number">1</span>]; <span class="comment">// 按照序号删除数组   数组中删除前面元素 后面元素也会自动前移</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------NSSet----------------</span></span><br><span class="line"><span class="built_in">NSSet</span> *set = [<span class="built_in">NSSet</span> set]; <span class="comment">// 创建一个空Set</span></span><br><span class="line"><span class="built_in">NSSet</span> *set1 = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"jack"</span>, <span class="string">@"rose"</span>, <span class="string">@"sam"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"set1:%@"</span>, set1); <span class="comment">// 打印整个Set</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"set1的元素个数:%ld"</span>, set1<span class="variable">.count</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"set随机取元素:%@"</span>, [set1 anyObject]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------NSMutableSet------------</span></span><br><span class="line"><span class="built_in">NSMutableSet</span> *mSet = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">[mSet addObject:<span class="string">@"jack"</span>]; <span class="comment">// 添加元素</span></span><br><span class="line">[mSet removeObject:<span class="string">@"jack"</span>]; <span class="comment">// 删除元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------NSDictionary--------------</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict = [<span class="built_in">NSDictionary</span> dictionary]; <span class="comment">// 空字典</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict1 = [<span class="built_in">NSDictionary</span> dictionaryWithObject:<span class="string">@"Jack"</span> forKey:<span class="string">@"key"</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *dict2 = @&#123;<span class="string">@"key1"</span>: <span class="string">@"value1"</span>, <span class="string">@"key2"</span>: <span class="string">@"value2"</span>, <span class="string">@"key3"</span>:<span class="string">@"value3"</span>&#125;; <span class="comment">// NSDictionary的便捷初始化方法</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"key1的值:%@"</span>, [dict2 objectForKey:<span class="string">@"key1"</span>]); <span class="comment">// 通过key取value</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"key2的值%@"</span>, dict2[<span class="string">@"key2"</span>]); <span class="comment">// 便捷的通过key取value 编译器特性</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"dict2:%@"</span>, dict2); <span class="comment">// 打印整个字典</span></span><br><span class="line">[dict2 count];<span class="comment">// 字典中键值对的数量</span></span><br><span class="line">[dict2 allKeys]; <span class="comment">// 取到字典当中所有的key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字典</span></span><br><span class="line">[dict2 enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSDictionary:%@--&gt;%@"</span>, key, obj);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------NSMutableDictionary----------------</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *mDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="comment">// 没有同名Key的时候做添加 有同名Key的时候做修改</span></span><br><span class="line">[mDict setObject:<span class="string">@"value"</span> forKey:<span class="string">@"key"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"key的值%@"</span>, mDict[<span class="string">@"key"</span>]);</span><br><span class="line">[mDict removeObjectForKey:<span class="string">@"key"</span>];<span class="comment">// 移除键值对</span></span><br></pre></td></tr></table></figure>
<h2 id="NSNumber">NSNumber</h2><p><code>NSNumber</code>只能包装数字类型，NSNumber之所以能包装基本数据类型对象是因为继承了NSValue。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *num = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">10</span>]; <span class="comment">// int -&gt; NSNumber 转换</span></span><br><span class="line"><span class="comment">// 基本数据类型 --&gt; OC对象类型 转换的便捷写法 编译器特性</span></span><br><span class="line"><span class="built_in">NSNumber</span> *num1 = @<span class="number">20.0</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *num2 = @YES;</span><br><span class="line">@<span class="string">'A'</span>; <span class="comment">// 字符 -&gt; NSNumber对象 值为A的ASCII码值65</span></span><br><span class="line"><span class="keyword">int</span> num3 = <span class="number">12</span>;</span><br><span class="line">@(num3); <span class="comment">// 变量 -&gt; NSNumber对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OC集合类中都不能存放非OC对象 所以10必须包装成对象类存放进字典</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dictionary = @&#123;<span class="string">@"number"</span>: <span class="string">@"jack"</span>, <span class="string">@"age"</span>: num&#125;;</span><br><span class="line"><span class="comment">// NSNumber --&gt; int 转换</span></span><br><span class="line"><span class="keyword">int</span> a = [num intValue];</span><br><span class="line"><span class="comment">// NSNumber --&gt; double 转换</span></span><br><span class="line"><span class="keyword">int</span> b = [num1 doubleValue];</span><br><span class="line"><span class="built_in">NSString</span> *strNum = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%d"</span>, a];</span><br><span class="line"><span class="comment">// NSString --&gt; int 转换</span></span><br><span class="line">[strNum intValue];</span><br></pre></td></tr></table></figure>
<h2 id="NSValue">NSValue</h2><p><code>NSValue</code>才是最终的包装类，才真正具备包装成对象的功能，而且不管是什么类型，都能包装。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体 --&gt; OC对象类型 NSValue</span></span><br><span class="line"><span class="built_in">NSValue</span> *value1 = [<span class="built_in">NSValue</span> valueWithPoint:<span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">10</span>)];</span><br><span class="line"><span class="built_in">NSValue</span> *value2 = [<span class="built_in">NSValue</span> valueWithSize:<span class="built_in">CGSizeMake</span>(<span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line"><span class="built_in">NSArray</span> *arr1 = @[value1, value2];</span><br><span class="line"><span class="comment">// NSValue --&gt; 结构体</span></span><br><span class="line">[value1 pointValue]; </span><br><span class="line">[value2 sizeValue];</span><br></pre></td></tr></table></figure>
<h2 id="NSDate">NSDate</h2><p><code>NSDate</code>是时间类，OC中时间单位是秒，不是毫秒。Java才是毫秒，PHP的时间单位也是秒。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建当前时间</span></span><br><span class="line"><span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"0时区的时间是:%@"</span>,date);</span><br><span class="line"><span class="comment">// 创建出比现在时间晚5秒的时间</span></span><br><span class="line"><span class="built_in">NSDate</span> *date1 = [<span class="built_in">NSDate</span> dateWithTimeInterval:<span class="number">5</span> sinceDate:date];</span><br><span class="line"><span class="comment">// 返回时间的秒值</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> seconds = [date1 timeIntervalSince1970];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---日期格式化---</span></span><br><span class="line"><span class="comment">// 初始化时间格式类</span></span><br><span class="line"><span class="built_in">NSDateFormatter</span> *fomatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line"><span class="comment">// 用字符串的形式设置时间格式</span></span><br><span class="line">[fomatter setDateFormat:<span class="string">@"yyyy-MM-dd HH:mm:ss"</span>];</span><br><span class="line"><span class="comment">// NSDate --&gt; NSString 转换</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"格式化时间:%@"</span>, [fomatter stringFromDate:date]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSString --&gt; NSDate 转换</span></span><br><span class="line"><span class="built_in">NSString</span> *time = <span class="string">@"2011/09/10 15:24"</span>;</span><br><span class="line">[fomatter setDateFormat:<span class="string">@"yyyy/mm/dd HH:mm"</span>];</span><br><span class="line"><span class="built_in">NSDate</span> *date2 = [fomatter dateFromString:time];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"订制时间:%@"</span>, date2);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 日期类 初始化格林高利日期</span></span><br><span class="line"><span class="built_in">NSCalendar</span> *calendar = [[<span class="built_in">NSCalendar</span> alloc] initWithCalendarIdentifier:<span class="built_in">NSGregorianCalendar</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSDateComponents表示时间时,必须添加单位,否则取出的单位时间会是错误的数值</span></span><br><span class="line"><span class="built_in">NSDateComponents</span> *components = [calendar components:<span class="built_in">NSYearCalendarUnit</span>|<span class="built_in">NSMonthCalendarUnit</span>|<span class="built_in">NSDayCalendarUnit</span>|<span class="built_in">NSHourCalendarUnit</span>|<span class="built_in">NSMinuteCalendarUnit</span>|<span class="built_in">NSSecondCalendarUnit</span> fromDate:date];</span><br><span class="line">components<span class="variable">.hour</span> = <span class="number">0</span>;</span><br><span class="line">components<span class="variable">.minute</span> = <span class="number">0</span>;</span><br><span class="line">components<span class="variable">.second</span> = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NSDate</span> *newDate = [calendar dateFromComponents:components];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Today:%@"</span>, newDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据两个时间点，定义NSDateComponents对象，从而获取这两个时间点的时差</span></span><br><span class="line"><span class="built_in">NSDateComponents</span> *dateComponents = [calendar components:<span class="built_in">NSYearCalendarUnit</span> fromDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:<span class="number">0</span>] toDate:[<span class="built_in">NSDate</span> date] options:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"number of years:%i"</span>, dateComponents<span class="variable">.year</span>);</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>首先，<code>Foundation框架</code>是iOS开发当中的基本框架，所以以下的知识点都是iOS开发中最最基础的。</p>
<h2 id="结构体">结构体</h2><ul>
<li><code>NSRange(location, length)</code></li>
<li><code>NSPoint/CGPoint(x, y)</code></li>
<li><code>NSSize/CGSize(width, height)</code></li>
<li><code>NSRect/CGRect(CGPoint, CGSize)</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"Hello iOS,This is a string."</span>;</span><br><span class="line"><span class="built_in">NSRange</span> range = [str rangeOfString:<span class="string">@"OS"</span>];</span><br><span class="line"><span class="keyword">if</span> (range<span class="variable">.location</span> == <span class="built_in">NSNotFound</span>) &#123; <span class="comment">// NSNotFound等于-1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"字符串找不到"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"匹配字符串在查找字符串的位置:%ld, 长度:%ld"</span>, range<span class="variable">.location</span>, range<span class="variable">.length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化写法</span></span><br><span class="line"><span class="built_in">CGPoint</span> point = <span class="built_in">NSMakePoint</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">CGPoint</span> point1 = <span class="built_in">CGPointMake</span>(<span class="number">20</span>, <span class="number">25</span>);</span><br><span class="line"><span class="built_in">NSSize</span> size = <span class="built_in">CGSizeMake</span>(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">80</span>);</span><br><span class="line"><span class="built_in">CGRect</span> rect1 = &#123;<span class="built_in">CGPointZero</span>, <span class="built_in">CGSizeMake</span>(<span class="number">200</span>, <span class="number">200</span>)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *strPoint = <span class="built_in">NSStringFromCGPoint</span>(point); <span class="comment">// 输出:&#123;10, 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CGPointZero</span> == <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 常用原点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较</span></span><br><span class="line"><span class="built_in">CGPointEqualToPoint</span>(point, point1);</span><br><span class="line"><span class="built_in">CGRectEqualToRect</span>(rect, rect1); <span class="comment">// 其他写法均类似 就不一一列举</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串">字符串</h2><ul>
<li><code>NSString</code> 不可变字符串</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化写法</span></span><br><span class="line"><span class="built_in">NSString</span> *string1 = <span class="string">@"123"</span>; <span class="comment">// 常用</span></span><br><span class="line"><span class="built_in">NSString</span> *string2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"string123"</span>]; <span class="comment">// 繁琐, 一般不用</span></span><br><span class="line"><span class="built_in">NSString</span> *string3 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"Age = %d"</span>, <span class="number">99</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言字符串-&gt;OC字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *ocString1 = [[<span class="built_in">NSString</span> alloc] initWithUTF8String:<span class="string">"C language string"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *ocString2 = [[<span class="built_in">NSString</span> alloc] stringWithUTF8String:<span class="string">"C language string"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// OC字符串-&gt;C语言字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cString = [<span class="string">@"OC string"</span> UTF8String];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line"><span class="built_in">NSString</span> *fileString = [[<span class="built_in">NSString</span> alloc] initWithContentsOfFile:<span class="string">@"/Users/Guo/Document/1.txt"</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li><code>NSMutableString</code> 可变字符串</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSMutableString是NSString的子类 方法继承</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *mutableStr = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"age is 10"</span>];</span><br><span class="line"><span class="comment">// 追加字符串</span></span><br><span class="line">[mutableStr appendString:<span class="string">@" 11 12"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSRange</span> range = [mutableStr rangeOfString:<span class="string">@" is"</span>];</span><br><span class="line"><span class="comment">// 删除范围内的字符串</span></span><br><span class="line">[mutableStr deleteCharactersInRange:range];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *unchangeableString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"age is 10"</span>];</span><br><span class="line"><span class="comment">// 重新创建出一个新的字符串 并且基于原字符串追加</span></span><br><span class="line"><span class="built_in">NSString</span> *unchangeableString1 = [unchangeableString stringByAppendingString:<span class="string">@" 11 12"</span>];</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Foundation" scheme="http://goirry.github.io/tags/Foundation/"/>
    
      <category term="OC" scheme="http://goirry.github.io/tags/OC/"/>
    
      <category term="iOS" scheme="http://goirry.github.io/tags/iOS/"/>
    
      <category term="iOS" scheme="http://goirry.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 语法(五) Block和Protocol]]></title>
    <link href="http://goirry.github.io/2015/08/10/objective-c-grammar05/"/>
    <id>http://goirry.github.io/2015/08/10/objective-c-grammar05/</id>
    <published>2015-08-10T10:39:24.000Z</published>
    <updated>2015-08-10T11:04:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Block">Block</h2><p>block用来保存一段代码，可以写在函数内部，可以运行时保存一段代码(函数做不到)。</p>
<p>block的标志: <code>^</code></p>
<p>block和函数的相同点:</p>
<ol>
<li>可以保存代码。</li>
<li>有返回值。</li>
<li>有形参。</li>
<li>调用方式一样。</li>
</ol>
<p>定义block变量:</p>
<ul>
<li>无参数、无返回值 <code>void (^BlockName)();</code></li>
<li>有参数、有返回值 <code>int (^BlockName)(int, int)</code></li>
</ul>
<p>利用block封装代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">^() &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参可以省略括号, 如下:</span></span><br><span class="line">^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参</span></span><br><span class="line">^(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (^MinusBlock)(<span class="keyword">int</span>, <span class="keyword">int</span>) = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (a - b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinusBlock(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure>
<p>block可以访问外部的变量。默认情况下，block内部不能修改外部的局部变量。给外部的局部变量加上<code>__block</code>关键字，就可以在block内部进行修改了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> sum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (^MyBlock)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    sum++;</span><br><span class="line">    <span class="keyword">return</span> (num * sum);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>可以利用typedef定义block变量:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^MySum)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">MySum sumBlock = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b);	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span style="color:#e73751">Tips:</span> 苹果官方建议尽量多使用block。在多线程、异步任务、集合遍历、集合排序、动画转场用的很多。</p>
<h2 id="Protocol">Protocol</h2><p>可以用来声明一大堆方法，但是不能声明成员变量。<br>只要某个类遵守了这个协议，就相当于拥有这个协议中的所有方法声明。<br>只要父类遵守了某个协议，就相当于子类也遵守了该协议。</p>
<p>某个类遵守协议:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明协议 与#import相比，"ProtocolName.h"性能更好，理由与@class相似</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProtocolName</span>; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义遵守协议的类 支持多协议 &lt;协议1, 协议2, 协议3&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassName</span> : <span class="title">SuperClass</span> &lt;<span class="title">ProtocolName</span>&gt; </span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>协议中的修饰关键字:<br><code>@required</code> 要求实现的方法，不实现会发出警告。<code>(默认)</code><br><code>@optional</code> 不要求实现的方法，可选性实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下的func1和func2是要求实现的，func3是可选实现的。</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="keyword">void</span>) func1;</span><br><span class="line">- (<span class="keyword">void</span>) func2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>) func3;</span><br></pre></td></tr></table></figure>
<p>协议使用的场合:<br>最多的是用在代理模式、观察者模式上。</p>
<p>基协议:<br><code>NSObject</code>是一个基类(最根本最基本的类)，还有一个协议，名字也叫<code>NSObject</code>，是基协议。建议每个新的协议都要遵守NSObject协议。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本协议的定义</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProtocolName</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>类的属性声明中:</p>
<p><code>@property (nonatomic, strong) id&lt;MyProtocol&gt; obj;</code>表明所有赋值给obj的对象都一定要遵守MyProtocol协议。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求保存对象的指针 保存的对象必须是遵守MyProtocol协议的</span></span><br><span class="line"><span class="keyword">id</span>&lt;MyProtocol&gt; obj = [[Person alloc] init];</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Block">Block</h2><p>block用来保存一段代码，可以写在函数内部，可以运行时保存一段代码(函数做不到)。</p>
<p>block的标志: <code>^</code></p>
<p>block和函数的相同点:</p>
<ol>
<li>可以保存代码。</li>
<li>有返回值。</li>
<li>有形参。</li>
<li>调用方式一样。</li>
</ol>
<p>定义block变量:</p>
<ul>
<li>无参数、无返回值 <code>void (^BlockName)();</code></li>
<li>有参数、有返回值 <code>int (^BlockName)(int, int)</code></li>
</ul>
<p>利用block封装代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">^() &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参可以省略括号, 如下:</span></span><br><span class="line">^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参</span></span><br><span class="line">^(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (^MinusBlock)(<span class="keyword">int</span>, <span class="keyword">int</span>) = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (a - b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinusBlock(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure>
<p>block可以访问外部的变量。默认情况下，block内部不能修改外部的局部变量。给外部的局部变量加上<code>__block</code>关键字，就可以在block内部进行修改了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> sum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (^MyBlock)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    sum++;</span><br><span class="line">    <span class="keyword">return</span> (num * sum);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="OC" scheme="http://goirry.github.io/tags/OC/"/>
    
      <category term="Objective-C" scheme="http://goirry.github.io/tags/Objective-C/"/>
    
      <category term="OC" scheme="http://goirry.github.io/categories/OC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 语法(四) OC内存]]></title>
    <link href="http://goirry.github.io/2015/08/09/objective-c-grammar04/"/>
    <id>http://goirry.github.io/2015/08/09/objective-c-grammar04/</id>
    <published>2015-08-09T10:15:36.000Z</published>
    <updated>2015-09-16T11:07:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="OC内存">OC内存</h2><p>每个OC对象都有自己的引用计数器，是整数，表示该对象被引用的次数。<br>当引用计数器为<code>0</code>的时候，对象就会被系统回收。</p>
<p>每个OC对象内部专门有<code>4个字节</code>的存储空间来存引用计数器。</p>
<p>给对象发送一条<code>retain</code>消息，引用计数器<code>+1</code>，<code>retain</code>方法返回对象本身。<br>给对象发送一条<code>release</code>消息， 引用计数器<code>-1</code>。<br>给对象发送<code>retainCount</code>消息获得引用计数器值。</p>
<h3 id="僵尸对象">僵尸对象</h3><p>所占用内存已经被回收的对象，僵尸对象不能再使用。</p>
<h3 id="野指针">野指针</h3><p>指向僵尸对象(不可用内存)的指针。</p>
<p><code>EXC_BAD_ACCESS</code>: 访问了一块坏的内存(已经被回收，不可用的内存)。</p>
<p>OC当中没有空指针异常。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[nil release]</span>; <span class="comment">// 不会报错</span></span><br></pre></td></tr></table></figure>
<p><span style="color:#e73751">Tips:</span> 基本数据类型不需要内存管理，OC对象才需要内存管理。</p>
<h3 id="dealloc方法">dealloc方法</h3><p>当一个对象要被回收，就会自定调用。<br>一定记得在重写的时候，在最后调用<code>[super dealloc];</code></p>
<h3 id="内存管理">内存管理</h3><p>只要调用了<code>alloc</code>、<code>new</code>、<code>retain</code>或<code>copy(mutablecopy)</code>，必须有<code>release或autorelease</code>。</p>
<h3 id="@property">@property</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@property</span> (retain) Book *book; <span class="comment">// 就可以生成严谨的有内存管理的setter和getter</span></span><br></pre></td></tr></table></figure>
<p>@property括号中的参数</p>
<ul>
<li>内存管理相关的3个参数:<ul>
<li><code>retain</code>: 使用于OC对象类型，有<code>retain</code>记得要<code>release</code>，这个会<code>release</code>旧值， 在<code>setter</code>中<code>retain</code>新值。</li>
<li><code>assign</code>: 直接赋值，适用于非OC对象类型。<code>(默认)</code> 出于代码规范，就算是默认值也需要写出来，显式总比隐式清晰明了。</li>
<li><code>copy</code>: <code>release</code>旧值，<code>retain</code>新值。</li>
</ul>
</li>
<li>是否要生成setter:<ul>
<li><code>readonly</code>: 不生成setter，只会生成getter</li>
<li><code>readwrite</code>: 同时生成setter和getter。<code>(默认)</code></li>
</ul>
</li>
<li>多线程管理:<ul>
<li><code>nonatomic</code>: 生成setter和getter时不加锁，性能高，一般就用这个。</li>
<li><code>atomic</code>: 生成setter和getter时加锁，性能低。<code>(默认)</code></li>
</ul>
</li>
<li>setter和getter方法名称的修改<ul>
<li><code>setter=setFunc:</code> set方法一定记得加<code>:</code>冒号</li>
<li><code>getter=func</code></li>
</ul>
</li>
</ul>
<a id="more"></a>
<p>iOS类中的属性声明规律:</p>
<ul>
<li><code>UI</code>控件用<code>weak</code></li>
<li><code>OC</code>对象用<code>strong</code></li>
<li>基本数据类型用<code>assign</code></li>
<li><code>NSString</code>用<code>copy</code></li>
</ul>
<p>代码规范: 返回BOOL类型的方法名，一般以<code>is</code>开头，所以返回BOOL值的getter可以写成<code>getter=isFunc</code>。</p>
<p><span style="color:#e73751">Tips:</span> 当两个类循环嵌套引用时，出现内存泄露的解决方案: 一端用<code>retain</code>，一段用<code>assign</code>。</p>
<h3 id="Autorelease">Autorelease</h3><p>autorelease会返回对象本身，返回id类型。<br>autorelease会将对象放到一个自动释放池中。调用时，不改变引用计数器的值。<br>当自动释放池(也是对象)被销毁时，会对池子里面的所有对象做一次release操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[[Person alloc] init] autorelease];</span><br></pre></td></tr></table></figure>
<p>自动释放池<code>@autoreleasepool{}</code>这是ios5.0之后的创建方式。<br>代码块开始代表创建了释放池，代码块结束代表销毁了释放池。</p>
<p>autorelease的好处:</p>
<ul>
<li>不用再关心对象释放的时间。</li>
<li>不用再关心什么时候调用<code>release</code>。</li>
</ul>
<p>autorelease的坏处:</p>
<ul>
<li>不能精确的控制对象释放的时间。</li>
</ul>
<p>@autoreleasepool{}本身可以自由嵌套<br>autorelease不是自动释放，是AutoreleasePool的实例，在runloop中被”稍后“释放。</p>
<p>autorelease的使用注意:</p>
<ul>
<li>占用内存较大的对象不要随便使用<code>autorelease</code>。</li>
<li>占用内存较小的对象使用<code>autorelease</code>没有太大的影响。</li>
</ul>
<p>错误写法:</p>
<ul>
<li>alloc之后调用了autorelease，又调用了release。</li>
<li>对同一个对象连续调用多次autorelease。</li>
</ul>
<p>自动释放池</p>
<ol>
<li>在<code>iOS</code>程序运行过程中，会创建无数个释放池，这些释放池都是以栈结构(弹匣式)存在。</li>
<li>当一个对象调用<code>autorelease</code>方式时，会将这个对象放到栈顶的释放池。</li>
</ol>
<p><span style="color:#e73751">Tips1:</span> 系统自带的方法里面没有包含<code>alloc</code>、<code>new</code>、<code>copy</code>，说明返回的对象都是<code>autorelease</code>的。<br><span style="color:#e73751">Tips2:</span> 被<code>retain</code>过的属性，必须在<code>dealloc</code>方法中<code>release</code>该属性。</p>
<h3 id="ARC">ARC</h3><p>ARC是自动引用计数，是<code>LLVM 3.0</code>编译器特性。</p>
<p>ARC的判断准则: 强引用保证对象的存在，或没有强引用，则对象被自动销毁</p>
<p>指针在ARC中分为<code>2</code>种:</p>
<ul>
<li>强指针: 默认情况下，所有的指针都是强指针<code>__strong</code>。</li>
<li>弱指针: 用<code>__weak</code>修饰的指针。</li>
</ul>
<p>ARC特点:</p>
<ol>
<li>不允许调用<code>release</code>、<code>retain</code>、<code>retainCount</code>、<code>autorelease</code>。</li>
<li>允许重写<code>dealloc</code>，但是不允许调用<code>[super dealloc];</code>。</li>
<li><code>@property</code>的参数:<ul>
<li>strong 强指针 适用于<code>OC</code>对象类型 引用计数器<code>+1</code>。</li>
<li>weak 弱指针 适用于<code>OC</code>对象类型 如果指向的对象被释放，其指向<code>nil</code>，可以有效避免野指针。</li>
<li>assign 适用于非<code>OC</code>对象类型 赋值特性，不涉及引用计数。</li>
</ul>
</li>
</ol>
<p><span style="color:#e73751">Tips:</span> 循环嵌套引用时，一端用<code>strong</code>，一端用<code>weak</code>。</p>
<h2 id="@class">@class</h2><p>@class仅仅是告诉编译器，当前声明的是一个类。<br>嵌套引用的时候用到<code>@class 类名;</code>，写在<code>.h</code>文件当中，不用<code>#import</code>。</p>
<p>开发中引用一个类的规范:</p>
<ol>
<li>在<code>.h</code>文件中用@class来声明类。</li>
<li>在<code>.m</code>文件中用<code>#import</code>来包含类所有的声明。这样，只有等到实现文件真正要用到的时候，才会去查看引用类。</li>
</ol>
<p>使用<code>@class</code>的好处及其与<code>#import</code>的区别:</p>
<ol>
<li><code>@class</code>可以解决循环引用的问题，而<code>#import</code>就会出现循环引用问题。</li>
<li><code>@class</code>可以提高性能，用<code>#import</code>时，这个类修改后，所有引用这个类的类都需要重新编译一遍。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="OC内存">OC内存</h2><p>每个OC对象都有自己的引用计数器，是整数，表示该对象被引用的次数。<br>当引用计数器为<code>0</code>的时候，对象就会被系统回收。</p>
<p>每个OC对象内部专门有<code>4个字节</code>的存储空间来存引用计数器。</p>
<p>给对象发送一条<code>retain</code>消息，引用计数器<code>+1</code>，<code>retain</code>方法返回对象本身。<br>给对象发送一条<code>release</code>消息， 引用计数器<code>-1</code>。<br>给对象发送<code>retainCount</code>消息获得引用计数器值。</p>
<h3 id="僵尸对象">僵尸对象</h3><p>所占用内存已经被回收的对象，僵尸对象不能再使用。</p>
<h3 id="野指针">野指针</h3><p>指向僵尸对象(不可用内存)的指针。</p>
<p><code>EXC_BAD_ACCESS</code>: 访问了一块坏的内存(已经被回收，不可用的内存)。</p>
<p>OC当中没有空指针异常。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[nil release]</span>; <span class="comment">// 不会报错</span></span><br></pre></td></tr></table></figure>
<p><span style="color:#e73751">Tips:</span> 基本数据类型不需要内存管理，OC对象才需要内存管理。</p>
<h3 id="dealloc方法">dealloc方法</h3><p>当一个对象要被回收，就会自定调用。<br>一定记得在重写的时候，在最后调用<code>[super dealloc];</code></p>
<h3 id="内存管理">内存管理</h3><p>只要调用了<code>alloc</code>、<code>new</code>、<code>retain</code>或<code>copy(mutablecopy)</code>，必须有<code>release或autorelease</code>。</p>
<h3 id="@property">@property</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@property</span> (retain) Book *book; <span class="comment">// 就可以生成严谨的有内存管理的setter和getter</span></span><br></pre></td></tr></table></figure>
<p>@property括号中的参数</p>
<ul>
<li>内存管理相关的3个参数:<ul>
<li><code>retain</code>: 使用于OC对象类型，有<code>retain</code>记得要<code>release</code>，这个会<code>release</code>旧值， 在<code>setter</code>中<code>retain</code>新值。</li>
<li><code>assign</code>: 直接赋值，适用于非OC对象类型。<code>(默认)</code> 出于代码规范，就算是默认值也需要写出来，显式总比隐式清晰明了。</li>
<li><code>copy</code>: <code>release</code>旧值，<code>retain</code>新值。</li>
</ul>
</li>
<li>是否要生成setter:<ul>
<li><code>readonly</code>: 不生成setter，只会生成getter</li>
<li><code>readwrite</code>: 同时生成setter和getter。<code>(默认)</code></li>
</ul>
</li>
<li>多线程管理:<ul>
<li><code>nonatomic</code>: 生成setter和getter时不加锁，性能高，一般就用这个。</li>
<li><code>atomic</code>: 生成setter和getter时加锁，性能低。<code>(默认)</code></li>
</ul>
</li>
<li>setter和getter方法名称的修改<ul>
<li><code>setter=setFunc:</code> set方法一定记得加<code>:</code>冒号</li>
<li><code>getter=func</code></li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
      <category term="OC" scheme="http://goirry.github.io/tags/OC/"/>
    
      <category term="Objective-C" scheme="http://goirry.github.io/tags/Objective-C/"/>
    
      <category term="OC" scheme="http://goirry.github.io/categories/OC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 语法(三) Category和SEL]]></title>
    <link href="http://goirry.github.io/2015/08/08/objective-c-grammar03/"/>
    <id>http://goirry.github.io/2015/08/08/objective-c-grammar03/</id>
    <published>2015-08-08T08:43:13.000Z</published>
    <updated>2015-08-08T08:59:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="分类_Category">分类 Category</h2><p>分类可以给某一个类扩充一些方法（在不修改原来类代码的基础上），很适合做类的拓展。</p>
<h3 id="声明:">声明:</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> 类名 (分类名)</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="实现:">实现:</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@implementation</span> 类名 (分类名)</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="分类的作用：">分类的作用：</h3><p>在不改变原来类内容的基础上，可以为类增加一些代码。</p>
<h3 id="分类注意点:">分类注意点:</h3><p>1.分类只能增加方法，不能增加成员变量。<br>2.分类方法实现中可以访问原类中的声明的成员变量。<br>3.分类可以重写原类中的方法。<br>4.方法调用的优先级: 分类 -&gt; 原类 -&gt; 父类</p>
<p>当程序启动的时候，就会加载一次项目中所有的类，类加载完毕后就会调用<code>+ load</code>方法。当第一次使用这个类的时候，就会调用一次<code>+ initialize</code>方法。<br>先加载父类，再加载子类。先初始化父类，再初始化子类。<br>分类必定在原类之后加载，最后参与编译的分类具有最高优先级。</p>
<a id="more"></a>
<h2 id="SEL">SEL</h2><p>SEL其实是对方法的一种包装，将方法包装成一个<code>SEL类型</code>的数据，所以SEL是一种数据类型。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">[p test];</span><br></pre></td></tr></table></figure>
<p>调用方法时，其实有3个步骤:</p>
<ol>
<li>把test先包装成SEL类型的数据。</li>
<li>根据SEL数据找到对应的内存中的方法地址。</li>
<li>根据方法地址调用对应的方法。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[p performSelector:<span class="keyword">@selector</span>(test)]; <span class="comment">// 同样也是调用test方法</span></span><br></pre></td></tr></table></figure>
<p><code>performSelector:</code>是一个对象方法，返回<code>id</code>类型数据。要求传入<code>SEL数据</code>的参数<br><code>@selector</code>就返回一个<code>SEL数据</code>，传入方法名作为参数就可以把方法名包装成<code>SEL数据</code>。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个方法是同样效果</span></span><br><span class="line">[p <span class="string">test2:</span>@<span class="string">"123"</span>];</span><br><span class="line">[p <span class="string">performSelector:</span><span class="annotation">@selector</span>(<span class="string">test2:</span>) <span class="string">withObject:</span>@<span class="string">"123"</span>];</span><br></pre></td></tr></table></figure>
<p><span style="color:#ff5c16">注意:</span><code>test2:</code>方法名后面的<code>:</code>冒号不能少，冒号也是方法名的一部分，表示后面需要传参。</p>
<p>我们常常说的发消息就是发送SEL类型的消息。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *funcName = <span class="string">@"test3"</span>;</span><br><span class="line">SEL s = <span class="built_in">NSSelectorFromString</span>(funcName); <span class="comment">// 把字符串包装成SEL数据</span></span><br><span class="line">[p performSelector:s];</span><br></pre></td></tr></table></figure>
<p>每个方法内部都有个<code>_cmd</code>的SEL数据，代表着当前方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="built_in">NSStringFromSelector</span>(_cmd); <span class="comment">// 把SEL转成字符串</span></span><br></pre></td></tr></table></figure>
<p><code>_cmd</code>就等于<code>@selector(当前方法名)</code>。</p>
<h2 id="NSLog">NSLog</h2><p>使用NSLog打印OC对象，使用<code>%@</code>占位符。<br>使用<code>NSLog和%@</code>打印对象时，会调用对象的<code>- description</code>方法。<br>然后拿到<code>- description</code>返回值(NSString *)显示。<br><code>- description</code>默认返回值是地址(句柄)，<code>- description</code>就等同于<code>Java</code>中的<code>toString</code>方法。<br>在<code>- description</code>中写<code>NSLog(@&quot;%@&quot;, self);</code>会进入死循环。</p>
<p>NSLog输出C语言字符串(%s)时，不能有中文，否则不打印输出结果，printf则不会有这样的问题。</p>
<p>NSLog输出增强</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, __LINE__); <span class="comment">// 打印行号</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __FILE__); <span class="comment">// 打印文件路径</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__); <span class="comment">// 打印当前方法名</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="分类_Category">分类 Category</h2><p>分类可以给某一个类扩充一些方法（在不修改原来类代码的基础上），很适合做类的拓展。</p>
<h3 id="声明:">声明:</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> 类名 (分类名)</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="实现:">实现:</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@implementation</span> 类名 (分类名)</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="分类的作用：">分类的作用：</h3><p>在不改变原来类内容的基础上，可以为类增加一些代码。</p>
<h3 id="分类注意点:">分类注意点:</h3><p>1.分类只能增加方法，不能增加成员变量。<br>2.分类方法实现中可以访问原类中的声明的成员变量。<br>3.分类可以重写原类中的方法。<br>4.方法调用的优先级: 分类 -&gt; 原类 -&gt; 父类</p>
<p>当程序启动的时候，就会加载一次项目中所有的类，类加载完毕后就会调用<code>+ load</code>方法。当第一次使用这个类的时候，就会调用一次<code>+ initialize</code>方法。<br>先加载父类，再加载子类。先初始化父类，再初始化子类。<br>分类必定在原类之后加载，最后参与编译的分类具有最高优先级。</p>]]>
    
    </summary>
    
      <category term="OC" scheme="http://goirry.github.io/tags/OC/"/>
    
      <category term="Objective-C" scheme="http://goirry.github.io/tags/Objective-C/"/>
    
      <category term="OC" scheme="http://goirry.github.io/categories/OC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 语法(二) 类]]></title>
    <link href="http://goirry.github.io/2015/04/23/objective-c-grammar02/"/>
    <id>http://goirry.github.io/2015/04/23/objective-c-grammar02/</id>
    <published>2015-04-23T09:28:41.000Z</published>
    <updated>2015-08-10T10:48:18.000Z</updated>
    <content type="html"><![CDATA[<p>类是面向对象语言中相当重要的一个知识点，也是最常用的知识点。</p>
<h2 id="类的概念">类的概念</h2><blockquote>
<p>OC当中的类其实原理就是C中的结构体</p>
<p>OC中创建一个类需要有两个步骤：类的声明、类的实现</p>
</blockquote>
<h2 id="类的声明和实现">类的声明和实现</h2><ul>
<li>类的声明：<code>@interface 类名 : 父类(继承类)</code><br> 大多都继承<code>NSObject</code>(基类)</li>
<li>类的实现：<code>@implementation 类名</code></li>
</ul>
<p>类的声明和类的实现都必须以<code>@end</code>结束</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的声明 继承NSObject</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;<span class="comment">//声明对象的属性 成员变量默认会初始化为0</span></span><br><span class="line">    <span class="comment">//@public可以让外部的指针间接访问对象内部的成员变量</span></span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _wheels;<span class="comment">//类的声明里的成员变量不允许初始化赋值,只能用来声明</span></span><br><span class="line">    <span class="keyword">double</span> _speed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只要是OC对象的方法,必须以减号 - 开头</span></span><br><span class="line"><span class="comment">//OC方法中任何数据类型都必须用小括号()括住</span></span><br><span class="line"><span class="comment">//OC方法中的小括号(): 只用来括住数据类型</span></span><br><span class="line">- (<span class="keyword">void</span>) run;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的实现 用来实现类的方法</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"><span class="comment">//方法的实现</span></span><br><span class="line">- (<span class="keyword">void</span>) run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用了run方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//利用类来创建对象或者调用类的方法 [行为执行者 行为名称]</span></span><br><span class="line">    <span class="comment">//new出的对象得到的都是指针，必须用对应类型的指针来指向</span></span><br><span class="line">    Car *myCar = [Car new];</span><br><span class="line">    <span class="comment">//用指针调用对象的属性，赋值或取值</span></span><br><span class="line">    myCar-&gt;wheels = <span class="number">4</span>;</span><br><span class="line">    myCar<span class="variable">.speed</span>  = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"车子有%d个轮子, 时速是%fkm/h"</span>, myCar-&gt;wheels, myCar-&gt;speed);</span><br><span class="line">    [myCar run];<span class="comment">//OC对象只能通过指针来操作 给myCar所指向对象发送一条run消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>任何OC对象都是通过指针来操控的。</p>
<p>每一个对象中都有一个<code>isa</code>指针指向对应的类，通过对象调用类中方法时，就是顺着<code>isa</code>指针找到类中的方法。</p>
</blockquote>
<p>成员变量是每个对象都有一份，方法则是共用同一份<br>成员变量和方法都不能用<code>static</code>等关键字修饰，不要跟C语言弄混淆</p>
<a id="more"></a>
<h2 id="对象方法">对象方法</h2><ol>
<li><code>-</code>号开头</li>
<li>只能由对象调用</li>
<li>对象方法中能访问当前对象的成员变量</li>
</ol>
<h2 id="类方法">类方法</h2><ol>
<li><code>+</code>号开头</li>
<li>只能由类调用</li>
<li>类方法中不能访问成员变量</li>
</ol>
<p><span style="color:#e73751">Tips:</span> 可以允许类方法和对象方法同名</p>
<h3 id="类方法的好处和使用场合">类方法的好处和使用场合</h3><ul>
<li>不依赖于对象，执行效率高</li>
<li>能用类方法尽量用类方法</li>
</ul>
<p>场合: 当方法内部不需要使用到成员变量时，就可以改为类方法</p>
<h2 id="方法声明和调用">方法声明和调用</h2><h3 id="方法声明">方法声明</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">double</span>)addNumber1:(<span class="keyword">double</span>)number1 andNumber2:(<span class="keyword">double</span>)number2;</span><br></pre></td></tr></table></figure>
<p><code>-</code>号说明是对象方法，<code>-</code>号后面的<code>(double)</code>是方法返回值类型，<code>addNumber1:andNumber2:</code>是方法名，<code>:</code>号后面的<code>(double)</code>是参数的类型，<code>number1</code>和<code>number2</code>则是形参。</p>
<p><span style="color:#ff5c16">注意:</span> 方法如果有参数，则方法名一定不能少了<code>:</code>号，否则找不到方法。</p>
<h3 id="方法调用">方法调用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[calc addNumber1:<span class="number">10</span> andNumber2:<span class="number">20</span>];</span><br></pre></td></tr></table></figure>
<p><code>calc</code>是计算器对象,调用了<code>addNumber1:andNumber2:</code>方法，<code>10</code>和<code>20</code>则是实参。</p>
<h2 id="方法和函数的区别">方法和函数的区别</h2><ol>
<li>OC方法的声明必须写在<code>@interface</code>和<code>@end</code>之间，只能实现在<code>@implementation</code>和<code>@end</code>之间。<br> 也就是说OC方法不能独立存在，依赖类的存在。<br> C的函数独立存在，函数能写在文件的任意位置(类的声明里除外)。</li>
<li>OC方法归类所有</li>
<li>函数能写在文件中的任意位置(类的声明里除外),函数归文件所有</li>
<li>函数调用不依赖对象,由于函数和类一点关系都没有,所以函数不能直接通过成员变量名或方法名去访问调用类的成员变量和方法</li>
</ol>
<p>没有<code>@interface</code>，只有<code>@implementation</code>，也能成功定义一个类。(弱语法)</p>
<p><code>@implementation</code>中不能声明和<code>@interface</code>一样的成员变量。(重复定义)</p>
<p><span style="color:#e73751">Tips:</span> 成员变量的命名规范:一定要以下划线<code>_</code>开头,和其他变量区别开来，系统默认生成和官方代码书写都是以<code>_</code>开头的。</p>
<h2 id="构造方法">构造方法</h2><p>自定义构造方法规范</p>
<ol>
<li>一定是对象方法，一定以<code>-</code>号开头。</li>
<li>返回值一般是id类型。</li>
<li>方法名一般以<code>init</code>开头。</li>
</ol>
<p><code>alloc</code>是类方法，作用是分配存储空间。<br><code>init</code>是对象方法，作用是构造方法、初始化。<br>这两个方法合起来就是new方法，不过一般都适用<code>[[类名 alloc] init]</code>来进行创建初始化对象。</p>
<h2 id="static_关键字">static 关键字</h2><p>使用<code>static</code>关键字可以声明变量为静态变量<br>静态变量<em>只在程序开始执行时初始化一次</em>，并一直存储在内存当中，哪怕修饰的是局部变量也一样。</p>
<p><span style="color:#ff5c16">注意:</span> 成员变量/方法<code>不能用static关键字</code>修饰，而C语言是可以的修饰变量和函数的，不要弄混。</p>
<h2 id="self_指针">self 指针</h2><p>概念：指向了当前对象(方法调用者)<br>所以谁调用方法，self就是谁。<br>当前类的对象调用对象方法，self就是当前类的对象。<br>当前类的子类对象调用对象方法，self就是当前类的子类对象。<br>当前类调用类方法，self就是当前类。</p>
<p><code>self-&gt;成员变量</code>可以访问当前对象内部的成员变量<br><code>[self 方法名]</code>可以调用当前对象的对象方法</p>
<h2 id="super">super</h2><p><code>[super 方法名];</code> 在子类重写方法中调用父类的方法。</p>
<p>使用场合: 子类重写父类<code>idea方法</code>时想保留父类的一些行为。</p>
<h2 id="多态">多态</h2><p>多态：父类指针指向子类对象</p>
<p><span style="color:#e73751">Tips:</span> OC是单继承的。</p>
<h2 id="点语法">点语法</h2><p>点语法的本质还是方法调用(<code>getter</code>和<code>setter</code>),不是直接访问调用成员变量。<br>没有<code>getter</code>和<code>setter</code>则不能使用点语法。</p>
<p><span style="color:#ff5c16">注意:</span> OC中，为了防止<code>self.age</code>误认为是访问成员变量<code>age</code>，所有的成员变量，推荐使用<code>_age</code>.</p>
<h2 id="修饰词">修饰词</h2><ul>
<li><code>@public</code> 在任何地方都能直接访问对象的成员变量。</li>
<li><code>@private</code> 只能在当前类的对象方法中访问，但在子类当中还是有，只是不能直接访问。</li>
<li><code>@protected</code> 能再当前类和子类的对象方法中直接访问（默认修饰）。</li>
<li><code>@package</code> 只要出在同一个框架中，就能直接访问对象的成员变量。</li>
</ul>
<p>在类的实现中定义成员变量一定是私有的，因为实现是写在<code>.m</code>文件中得，其他文件不能加载包含<code>.m</code>文件。加上<code>@public</code>也没用，因为访问不到。</p>
<h2 id="@property和@synthesize">@property和@synthesize</h2><p><code>@property</code> 可以自动生成某个成员变量的<code>setter</code>和<code>getter</code>声明。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@property</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure></p>
<p><code>@synthesize</code> 自动生成成员变量的<code>setter</code>和<code>getter</code>实现，并且会访问<code>_age</code>这个成员变量。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">synthesize</span> age = _age</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>@synthesize age</code>去实现<code>@property int age</code><br><code>= _age</code>去访问成员变量<code>_age</code>来填充<code>setter</code>和<code>getter</code></p>
<p>如果成员变量不存在(没有在<code>.h</code>文件中创建)，就会在<code>@implemention</code>中自动生成<code>@private</code>的成员变量。</p>
<p>最简写法: 只在<code>@interface</code>中写<code>@property int age;</code>就会自动生成成员变量及其<code>setter</code>和<code>getter</code>,不用再写@synthesize了。</p>
<p><span style="color:#e73751">Tips:</span> 自动生成的成员变量是<code>@protected</code>，并且如果自己写了<code>setter</code>或<code>getter</code>则所有自动生成的全都不生成。</p>
<h2 id="重写">重写</h2><p>重写 <code>- init</code>方法<br>重写时，一定要先调用<code>self = [super init]</code>方法去初始化父类中得成员变量。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>类是面向对象语言中相当重要的一个知识点，也是最常用的知识点。</p>
<h2 id="类的概念">类的概念</h2><blockquote>
<p>OC当中的类其实原理就是C中的结构体</p>
<p>OC中创建一个类需要有两个步骤：类的声明、类的实现</p>
</blockquote>
<h2 id="类的声明和实现">类的声明和实现</h2><ul>
<li>类的声明：<code>@interface 类名 : 父类(继承类)</code><br> 大多都继承<code>NSObject</code>(基类)</li>
<li>类的实现：<code>@implementation 类名</code></li>
</ul>
<p>类的声明和类的实现都必须以<code>@end</code>结束</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的声明 继承NSObject</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;<span class="comment">//声明对象的属性 成员变量默认会初始化为0</span></span><br><span class="line">    <span class="comment">//@public可以让外部的指针间接访问对象内部的成员变量</span></span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _wheels;<span class="comment">//类的声明里的成员变量不允许初始化赋值,只能用来声明</span></span><br><span class="line">    <span class="keyword">double</span> _speed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只要是OC对象的方法,必须以减号 - 开头</span></span><br><span class="line"><span class="comment">//OC方法中任何数据类型都必须用小括号()括住</span></span><br><span class="line"><span class="comment">//OC方法中的小括号(): 只用来括住数据类型</span></span><br><span class="line">- (<span class="keyword">void</span>) run;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的实现 用来实现类的方法</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"><span class="comment">//方法的实现</span></span><br><span class="line">- (<span class="keyword">void</span>) run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用了run方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//利用类来创建对象或者调用类的方法 [行为执行者 行为名称]</span></span><br><span class="line">    <span class="comment">//new出的对象得到的都是指针，必须用对应类型的指针来指向</span></span><br><span class="line">    Car *myCar = [Car new];</span><br><span class="line">    <span class="comment">//用指针调用对象的属性，赋值或取值</span></span><br><span class="line">    myCar-&gt;wheels = <span class="number">4</span>;</span><br><span class="line">    myCar<span class="variable">.speed</span>  = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"车子有%d个轮子, 时速是%fkm/h"</span>, myCar-&gt;wheels, myCar-&gt;speed);</span><br><span class="line">    [myCar run];<span class="comment">//OC对象只能通过指针来操作 给myCar所指向对象发送一条run消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>任何OC对象都是通过指针来操控的。</p>
<p>每一个对象中都有一个<code>isa</code>指针指向对应的类，通过对象调用类中方法时，就是顺着<code>isa</code>指针找到类中的方法。</p>
</blockquote>
<p>成员变量是每个对象都有一份，方法则是共用同一份<br>成员变量和方法都不能用<code>static</code>等关键字修饰，不要跟C语言弄混淆</p>]]>
    
    </summary>
    
      <category term="OC" scheme="http://goirry.github.io/tags/OC/"/>
    
      <category term="Objective-C" scheme="http://goirry.github.io/tags/Objective-C/"/>
    
      <category term="OC" scheme="http://goirry.github.io/categories/OC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 语法(一) 基本知识]]></title>
    <link href="http://goirry.github.io/2015/04/22/objective-c-grammar01/"/>
    <id>http://goirry.github.io/2015/04/22/objective-c-grammar01/</id>
    <published>2015-04-22T10:19:41.000Z</published>
    <updated>2015-08-08T09:07:26.000Z</updated>
    <content type="html"><![CDATA[<p>首先说明一下，这个Objective-C语法系列是笔者个人的学习笔记，所讲述的语法不会像语法书当中那么详细，只是一些备忘的知识点。<br>由于本人自身情况，短时间内学习的语言较多，怕各种语法纠杂在一起，梳理不清，特此记录。如果有朋友对此感兴趣，大家共勉学习。</p>
<h2 id="OC概念">OC概念</h2><p>在C语言的基础上，增加了一层最小的面向对象语法。<br>可以在OC代码中混入C语言代码，甚至是C++代码。</p>
<h2 id="关键字">关键字</h2><blockquote>
<h3 id="基本所有的关键字都以@开头">基本所有的关键字都以@开头</h3></blockquote>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span>、<span class="variable">@implementation</span>、<span class="variable">@end</span> </span><br><span class="line"><span class="variable">@public</span>、<span class="variable">@protected</span>、<span class="variable">@private</span>、<span class="variable">@selector</span> </span><br><span class="line"><span class="variable">@try</span>、<span class="variable">@catch</span>、<span class="variable">@throw</span>、<span class="variable">@finally</span>  </span><br><span class="line"><span class="variable">@protocol</span>、<span class="variable">@optional</span>、<span class="variable">@required</span>、<span class="variable">@class</span></span><br><span class="line"><span class="variable">@property</span>、<span class="variable">@synthesize</span>、<span class="variable">@dynamic</span></span><br><span class="line">self、super、id、_cmd、__block、__strong、__weak</span><br></pre></td></tr></table></figure>
<h2 id="基本数据类型">基本数据类型</h2><h3 id="int_整型">int 整型</h3><ul>
<li>8进制输出 : <code>%#o</code></li>
<li>16进制输出 : <code>%#x</code></li>
</ul>
<h3 id="float_单精度浮点型">float 单精度浮点型</h3><p>表示需要在浮点数后面加<code>f</code>，如: <code>12.5f</code></p>
<ul>
<li><code>%e</code> 科学计数法 以标准指数形式输出单双精度数，数字部分小数位数为<code>6</code>位</li>
<li><code>%f</code> 浮点计数法 以小数形式输出单双精度数，默认输出<code>6</code>位小数</li>
<li><code>%g</code> NSLog根据指数的值进行判断是使用浮点计数法或是科学计数法。小于<code>-4</code>或大于<code>5</code>，采用<code>%e</code>，否则采用<code>%f</code></li>
</ul>
<a id="more"></a>
<h3 id="double_双精度浮点型">double 双精度浮点型</h3><p>默认所有的小数都是<code>double</code>类型</p>
<p>输出和<code>float</code>一样</p>
<h3 id="char_字符型">char 字符型</h3><p><code>%c</code> 输出单个字符</p>
<h3 id="BOOL_布尔值">BOOL 布尔值</h3><ul>
<li><code>YES</code> 整型输出为<code>1</code> 只有<code>1</code>等同于<code>YES</code></li>
<li><code>NO</code>  整型输出为<code>0</code></li>
</ul>
<h3 id="限定词">限定词</h3><p><code>long, long long, short, unsigned, signed</code></p>
<ul>
<li><strong>long</strong> : <code>%li</code>    加<code>L</code>表示: <code>1.2e+7L</code></li>
<li><strong>long long</strong> : <code>%lli</code> </li>
<li><strong>short</strong> : <code>%hi</code>, <code>%ho</code>, <code>%hx</code></li>
<li><strong>unsigned</strong> 加<code>U</code>表示: <code>0x00ffU</code></li>
</ul>
<h2 id="NSLog与printf的区别">NSLog与printf的区别</h2><p><code>NSLog</code>接收<code>OC字符串</code>作为参数，<code>printf</code>接收<code>C语言字符串</code>作为参数<br><code>NSLog</code>输出后会自动换行，<code>printf</code>输出后不会自动换行</p>
<p>使用<code>NSLog</code>需要 <code>#import &lt;Foundation/Foundation.h&gt;</code><br>使用<code>printf</code>需要 <code>#include &lt;stdio.h&gt;</code></p>
<h2 id="编译执行程序指令">编译执行程序指令</h2><ol>
<li>编译: <code>cc -c main.m</code></li>
<li>链接: <code>cc main.o -framework Foundation</code></li>
<li>运行: <code>./a.out</code></li>
</ol>
<p><span style="color:#e73751">Tips:</span> 编译加链接:<code>cc main.m -framework Foundation</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先说明一下，这个Objective-C语法系列是笔者个人的学习笔记，所讲述的语法不会像语法书当中那么详细，只是一些备忘的知识点。<br>由于本人自身情况，短时间内学习的语言较多，怕各种语法纠杂在一起，梳理不清，特此记录。如果有朋友对此感兴趣，大家共勉学习。</p>
<h2 id="OC概念">OC概念</h2><p>在C语言的基础上，增加了一层最小的面向对象语法。<br>可以在OC代码中混入C语言代码，甚至是C++代码。</p>
<h2 id="关键字">关键字</h2><blockquote>
<h3 id="基本所有的关键字都以@开头">基本所有的关键字都以@开头</h3></blockquote>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span>、<span class="variable">@implementation</span>、<span class="variable">@end</span> </span><br><span class="line"><span class="variable">@public</span>、<span class="variable">@protected</span>、<span class="variable">@private</span>、<span class="variable">@selector</span> </span><br><span class="line"><span class="variable">@try</span>、<span class="variable">@catch</span>、<span class="variable">@throw</span>、<span class="variable">@finally</span>  </span><br><span class="line"><span class="variable">@protocol</span>、<span class="variable">@optional</span>、<span class="variable">@required</span>、<span class="variable">@class</span></span><br><span class="line"><span class="variable">@property</span>、<span class="variable">@synthesize</span>、<span class="variable">@dynamic</span></span><br><span class="line">self、super、id、_cmd、__block、__strong、__weak</span><br></pre></td></tr></table></figure>
<h2 id="基本数据类型">基本数据类型</h2><h3 id="int_整型">int 整型</h3><ul>
<li>8进制输出 : <code>%#o</code></li>
<li>16进制输出 : <code>%#x</code></li>
</ul>
<h3 id="float_单精度浮点型">float 单精度浮点型</h3><p>表示需要在浮点数后面加<code>f</code>，如: <code>12.5f</code></p>
<ul>
<li><code>%e</code> 科学计数法 以标准指数形式输出单双精度数，数字部分小数位数为<code>6</code>位</li>
<li><code>%f</code> 浮点计数法 以小数形式输出单双精度数，默认输出<code>6</code>位小数</li>
<li><code>%g</code> NSLog根据指数的值进行判断是使用浮点计数法或是科学计数法。小于<code>-4</code>或大于<code>5</code>，采用<code>%e</code>，否则采用<code>%f</code></li>
</ul>]]>
    
    </summary>
    
      <category term="OC" scheme="http://goirry.github.io/tags/OC/"/>
    
      <category term="Objective-C" scheme="http://goirry.github.io/tags/Objective-C/"/>
    
      <category term="OC" scheme="http://goirry.github.io/categories/OC/"/>
    
  </entry>
  
</feed>
